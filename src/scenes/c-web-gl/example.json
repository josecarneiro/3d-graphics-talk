"const canvas = document.createElement('canvas');\n\ncanvas.width = 600;\ncanvas.height = 600;\n\ndocument.body.appendChild(canvas);\n\nconst gl = canvas.getContext('webgl');\n\nconst vertices = [\n  -1,-1,-1, 1,-1,-1, 1, 1,-1, -1, 1,-1,\n  -1,-1, 1, 1,-1, 1, 1, 1, 1, -1, 1, 1,\n  -1,-1,-1, -1, 1,-1, -1, 1, 1, -1,-1, 1,\n  1,-1,-1, 1, 1,-1, 1, 1, 1, 1,-1, 1,\n  -1,-1,-1, -1,-1, 1, 1,-1, 1, 1,-1,-1,\n  -1, 1,-1, -1, 1, 1, 1, 1, 1, 1, 1,-1, \n];\n\nconst colors = [\n  1,0,0, 1,0,0, 1,0,0, 1,0,0,\n  1,0,0, 1,0,0, 1,0,0, 1,0,0,\n  1,0,0, 1,0,0, 1,0,0, 1,0,0,\n  1,0,0, 1,0,0, 1,0,0, 1,0,0,\n  1,0,0, 1,0,0, 1,0,0, 1,0,0,\n  1,0,0, 1,0,0, 1,0,0, 1,0,0\n];\n\nconst indices = [\n  0, 1, 2,   0, 2, 3,  4, 5, 6,  4, 6, 7,\n  8, 9, 10,  8,10,11, 12,13,14, 12,14,15,\n  16,17,18, 16,18,19, 20,21,22, 20,22,23 \n];\n\nconst vertexBuffer = gl.createBuffer();\ngl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\ngl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\n\nconst colorBuffer = gl.createBuffer();\ngl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);\ngl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);\n\nconst indexBuffer = gl.createBuffer();\ngl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\ngl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);\n\nconst vertCode = 'attribute vec3 position;'+\n  'uniform mat4 Pmatrix;'+\n  'uniform mat4 Vmatrix;'+\n  'uniform mat4 Mmatrix;'+\n  'attribute vec3 color;'+\n  'varying vec3 vColor;'+\n\n  'void main(void) { '+\n    'gl_Position = Pmatrix * Vmatrix * Mmatrix * vec4(position, 1.0);'+\n    'vColor = color;'+\n  '}';\n\nconst fragCode = 'precision mediump float;'+\n  'varying vec3 vColor;'+\n  'void main(void) {'+\n    'gl_FragColor = vec4(vColor, 1.);'+\n  '}';\n\nconst vertShader = gl.createShader(gl.VERTEX_SHADER);\ngl.shaderSource(vertShader, vertCode);\ngl.compileShader(vertShader);\n\nconst fragShader = gl.createShader(gl.FRAGMENT_SHADER);\ngl.shaderSource(fragShader, fragCode);\ngl.compileShader(fragShader);\n\nconst shaderProgram = gl.createProgram();\ngl.attachShader(shaderProgram, vertShader);\ngl.attachShader(shaderProgram, fragShader);\ngl.linkProgram(shaderProgram);\n\nconst Pmatrix = gl.getUniformLocation(shaderProgram, \"Pmatrix\");\nconst Vmatrix = gl.getUniformLocation(shaderProgram, \"Vmatrix\");\nconst Mmatrix = gl.getUniformLocation(shaderProgram, \"Mmatrix\");\n\ngl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\nconst position = gl.getAttribLocation(shaderProgram, \"position\");\ngl.vertexAttribPointer(position, 3, gl.FLOAT, false,0,0);\n\n// Position\ngl.enableVertexAttribArray(position);\ngl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);\nconst color = gl.getAttribLocation(shaderProgram, \"color\");\ngl.vertexAttribPointer(color, 3, gl.FLOAT, false,0,0);\n\n// Color\ngl.enableVertexAttribArray(color);\ngl.useProgram(shaderProgram);\n\nfunction getProjection(angle: number, a: number, zMin: number, zMax: number) {\n  const ang = Math.tan((angle * 0.5) * Math.PI/180);\n  return [\n    0.5 / ang, 0 , 0, 0,\n    0, 0.5 * a / ang, 0, 0,\n    0, 0, -(zMax + zMin) / (zMax - zMin), -1,\n    0, 0, (-2 * zMax * zMin) / (zMax - zMin), 0 \n  ];\n}\n\nconst projMatrix = getProjection(40, canvas.width / canvas.height, 1, 100);\nconst movMatrix = [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1];\nconst viewMatrix = [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1];\n\nviewMatrix[14] = viewMatrix[14] - 6;\n\nfunction rotateZ(m, angle) {\n  const c = Math.cos(angle);\n  const s = Math.sin(angle);\n  const mv0 = m[0];\n  const mv4 = m[4];\n  const mv8 = m[8];\n\n  m[0] = c*m[0]-s*m[1];\n  m[4] = c*m[4]-s*m[5];\n  m[8] = c*m[8]-s*m[9];\n\n  m[1]=c*m[1]+s*mv0;\n  m[5]=c*m[5]+s*mv4;\n  m[9]=c*m[9]+s*mv8;\n}\n\nfunction rotateX(m, angle) {\n  const c = Math.cos(angle);\n  const s = Math.sin(angle);\n  const mv1 = m[1];\n  const mv5 = m[5];\n  const mv9 = m[9];\n\n  m[1] = m[1]*c-m[2]*s;\n  m[5] = m[5]*c-m[6]*s;\n  m[9] = m[9]*c-m[10]*s;\n\n  m[2] = m[2]*c+mv1*s;\n  m[6] = m[6]*c+mv5*s;\n  m[10] = m[10]*c+mv9*s;\n}\n\nfunction rotateY(m, angle) {\n  const c = Math.cos(angle);\n  const s = Math.sin(angle);\n  const mv0 = m[0];\n  const mv4 = m[4];\n  const mv8 = m[8];\n\n  m[0] = c*m[0]+s*m[2];\n  m[4] = c*m[4]+s*m[6];\n  m[8] = c*m[8]+s*m[10];\n\n  m[2] = c*m[2]-s*mv0;\n  m[6] = c*m[6]-s*mv4;\n  m[10] = c*m[10]-s*mv8;\n}\n\nlet timeOld = 0;\n\nfunction animate(time) {\n  const dt = time - timeOld;\n  rotateZ(movMatrix, dt * 0.0005);\n  rotateY(movMatrix, dt * 0.0002);\n  rotateX(movMatrix, dt * 0.0003);\n  timeOld = time;\n\n  gl.enable(gl.DEPTH_TEST);\n  gl.depthFunc(gl.LEQUAL);\n  gl.clearColor(0.5, 0.5, 0.5, 0.0);\n  gl.clearDepth(1.0);\n  \n  gl.viewport(0.0, 0.0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n  gl.uniformMatrix4fv(Pmatrix, false, projMatrix);\n  gl.uniformMatrix4fv(Vmatrix, false, viewMatrix);\n  gl.uniformMatrix4fv(Mmatrix, false, movMatrix);\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\n  gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);\n\n  window.requestAnimationFrame(animate);\n}\n\nanimate(0);"
